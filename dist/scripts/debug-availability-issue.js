"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// src/scripts/debug-availability-issue.ts
const availability_1 = require("../service/availability");
const supabase_1 = require("../config/supabase");
const google_calendar_1 = require("../config/google_calendar");
const luxon_1 = require("luxon");
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
async function debugAvailabilityIssue() {
    console.log('üîç Starting availability suggestions debug...\n');
    // Usar os mesmos par√¢metros da sua requisi√ß√£o
    const testParams = {
        service_id: "8e5fa7fc-7095-4b10-b99b-965fd1a81ecc",
        start_datetime: "2025-08-26T14:00:00.000-03:00",
        end_datetime: "2025-08-26T15:00:00.000-03:00",
        calendar_ids: [
            "c0170c60-6640-4d70-936b-486a148cc375",
            "c0ec4dd5-e2b6-4f64-8e13-3fe55aab6f5e"
        ],
        max_results: 15,
        expand_timeframe: true,
        interval_minutes: 30,
        strategy: "earliest"
    };
    try {
        // 1. VERIFICAR DADOS B√ÅSICOS
        console.log('üìã 1. Verificando dados b√°sicos...');
        const { data: service, error: serviceError } = await supabase_1.supabase
            .from('services')
            .select('*')
            .eq('id', testParams.service_id)
            .single();
        if (serviceError || !service) {
            console.error('‚ùå Erro ao buscar servi√ßo:', serviceError);
            return;
        }
        console.log('‚úÖ Dados do servi√ßo:', {
            id: service.id,
            name: service.name,
            duration: service.duration,
            buffer_before: service.buffer_before || 0,
            buffer_after: service.buffer_after || 0,
            is_active: service.is_active
        });
        // 2. VERIFICAR CALEND√ÅRIOS
        console.log('\nüìã 2. Verificando calend√°rios...');
        const { data: calendars, error: calendarsError } = await supabase_1.supabase
            .from('calendars')
            .select('id, name, google_calendar_id, priority, instance_id, is_active')
            .in('id', testParams.calendar_ids)
            .eq('is_active', true)
            .order('priority');
        if (calendarsError || !calendars || calendars.length === 0) {
            console.error('‚ùå Erro ao buscar calend√°rios:', calendarsError);
            return;
        }
        console.log('‚úÖ Calend√°rios encontrados:', calendars.map(cal => ({
            id: cal.id,
            name: cal.name,
            google_calendar_id: cal.google_calendar_id,
            priority: cal.priority,
            is_active: cal.is_active
        })));
        // 3. VERIFICAR EVENTOS EXISTENTES EM CADA CALEND√ÅRIO NO PER√çODO
        console.log('\nüìã 3. Verificando eventos existentes no per√≠odo...');
        const searchStart = luxon_1.DateTime.fromISO(testParams.start_datetime);
        const searchEnd = luxon_1.DateTime.fromISO(testParams.end_datetime);
        for (const cal of calendars) {
            console.log(`\nüîç Verificando calend√°rio: ${cal.name}`);
            try {
                const response = await google_calendar_1.calendar.events.list({
                    calendarId: cal.google_calendar_id,
                    timeMin: searchStart.toJSDate().toISOString(),
                    timeMax: searchEnd.plus({ days: 1 }).toJSDate().toISOString(), // +1 dia para ver mais eventos
                    singleEvents: true,
                    orderBy: 'startTime',
                    maxResults: 50
                });
                const events = response.data.items || [];
                console.log(`üìä Eventos encontrados: ${events.length}`);
                events.forEach((event, index) => {
                    const eventStart = event.start?.dateTime || event.start?.date;
                    const eventEnd = event.end?.dateTime || event.end?.date;
                    console.log(`  ${index + 1}. ${event.summary || 'Sem t√≠tulo'}`);
                    console.log(`     In√≠cio: ${eventStart}`);
                    console.log(`     Fim: ${eventEnd}`);
                    console.log(`     Status: ${event.status}`);
                    console.log(`     Transparency: ${event.transparency || 'opaque'}`);
                    console.log(`     ID: ${event.id}`);
                    // Verificar se este evento estaria em conflito com um slot √†s 14:00
                    if (eventStart && eventEnd) {
                        const eStart = new Date(eventStart);
                        const eEnd = new Date(eventEnd);
                        const testSlotStart = searchStart.toJSDate();
                        const testSlotEnd = searchStart.plus({ minutes: service.duration }).toJSDate();
                        const hasOverlap = (eStart < testSlotEnd) && (eEnd > testSlotStart);
                        const wouldBlock = hasOverlap && event.transparency !== 'transparent' && event.status !== 'cancelled';
                        console.log(`     Conflita com 14:00: ${hasOverlap ? 'üî¥ SIM' : 'üü¢ N√ÉO'}`);
                        console.log(`     Bloquearia: ${wouldBlock ? 'üî¥ SIM' : 'üü¢ N√ÉO'}`);
                    }
                    console.log('');
                });
            }
            catch (error) {
                console.error(`‚ùå Erro ao verificar calend√°rio ${cal.name}:`, error);
            }
        }
        // 4. TESTAR A API DE SUGEST√ïES DIRETAMENTE
        console.log('\nüìã 4. Testando API de sugest√µes...');
        const availabilityService = new availability_1.AvailabilityService();
        console.log('Par√¢metros da requisi√ß√£o:', testParams);
        const suggestions = await availabilityService.suggestAvailability(testParams.start_datetime, testParams.end_datetime, testParams.service_id, testParams.calendar_ids, testParams.max_results, testParams.expand_timeframe, testParams.interval_minutes, testParams.strategy);
        console.log('\nüìä RESULTADOS DA API:');
        console.log(`Total de sugest√µes: ${suggestions.length}`);
        suggestions.forEach((suggestion, index) => {
            console.log(`\n${index + 1}. Hor√°rio sugerido:`);
            console.log(`   In√≠cio: ${suggestion.start_datetime}`);
            console.log(`   Fim: ${suggestion.end_datetime}`);
            console.log(`   Calend√°rio: ${suggestion.calendar_name}`);
            console.log(`   Prioridade: ${suggestion.priority}`);
            // Para cada sugest√£o, verificar manualmente se h√° conflitos
            const suggestionStart = luxon_1.DateTime.fromISO(suggestion.start_datetime);
            const suggestionEnd = luxon_1.DateTime.fromISO(suggestion.end_datetime);
            console.log(`   üîç Verifica√ß√£o manual do slot...`);
        });
        // 5. VERIFICA√á√ÉO MANUAL DE UM HOR√ÅRIO ESPEC√çFICO
        console.log('\nüìã 5. Verifica√ß√£o manual do hor√°rio 14:00...');
        for (const cal of calendars) {
            console.log(`\nüîç Verificando manualmente ${cal.name} √†s 14:00:`);
            const checkResult = await availabilityService.checkAvailability("2025-08-26T14:00:00.000-03:00", testParams.service_id, cal.id);
            console.log('üìä Resultado da verifica√ß√£o manual:', {
                available: checkResult.available,
                conflict_reason: checkResult.conflict_reason,
                calendar_name: checkResult.calendar_name
            });
            // Verifica√ß√£o direta no Google Calendar
            const startTime = luxon_1.DateTime.fromISO("2025-08-26T14:00:00.000-03:00");
            const endTime = startTime.plus({ minutes: service.duration });
            const totalStart = startTime.minus({ minutes: service.buffer_before || 0 });
            const totalEnd = endTime.plus({ minutes: service.buffer_after || 0 });
            try {
                const directResponse = await google_calendar_1.calendar.events.list({
                    calendarId: cal.google_calendar_id,
                    timeMin: totalStart.toJSDate().toISOString(),
                    timeMax: totalEnd.toJSDate().toISOString(),
                    singleEvents: true,
                    orderBy: 'startTime'
                });
                const directEvents = directResponse.data.items || [];
                console.log(`üìä Verifica√ß√£o direta no Google: ${directEvents.length} eventos encontrados`);
                directEvents.forEach(event => {
                    const eventStart = event.start?.dateTime || event.start?.date;
                    const eventEnd = event.end?.dateTime || event.end?.date;
                    console.log(`  - ${event.summary || 'Sem t√≠tulo'}`);
                    console.log(`    ${eventStart} at√© ${eventEnd}`);
                    console.log(`    Status: ${event.status}, Transparency: ${event.transparency || 'opaque'}`);
                });
            }
            catch (error) {
                console.error(`‚ùå Erro na verifica√ß√£o direta:`, error);
            }
        }
        // 6. VERIFICAR AGENDAMENTOS NO BANCO DE DADOS
        console.log('\nüìã 6. Verificando agendamentos no banco de dados...');
        const { data: dbAppointments, error: appointmentsError } = await supabase_1.supabase
            .from('appointments')
            .select(`
        id,
        title,
        start_datetime,
        end_datetime,
        status,
        google_event_id,
        calendar_id,
        calendars(name, google_calendar_id)
      `)
            .in('calendar_id', testParams.calendar_ids)
            .gte('start_datetime', '2025-08-26 00:00:00')
            .lte('start_datetime', '2025-08-26 23:59:59')
            .order('start_datetime');
        if (!appointmentsError && dbAppointments) {
            console.log(`üìä Agendamentos no banco: ${dbAppointments.length}`);
            dbAppointments.forEach(apt => {
                console.log(`  - ${apt.title}`);
                console.log(`    ${apt.start_datetime} at√© ${apt.end_datetime}`);
                console.log(`    Status: ${apt.status}`);
                const calInfo = Array.isArray(apt.calendars) ? apt.calendars[0] : apt.calendars;
                console.log(`    Calendar: ${calInfo?.name}`);
                console.log(`    Google Event ID: ${apt.google_event_id}`);
            });
        }
        // 7. AN√ÅLISE FINAL
        console.log('\nüìä AN√ÅLISE FINAL:');
        console.log('================');
        console.log(`API sugere ${suggestions.length} hor√°rios`);
        // Verificar se alguma sugest√£o conflita com eventos existentes
        const conflictingSuggestions = [];
        for (const suggestion of suggestions) {
            const suggestionStart = luxon_1.DateTime.fromISO(suggestion.start_datetime);
            const calendarData = calendars.find(c => c.id === suggestion.calendar_id);
            if (!calendarData)
                continue;
            try {
                const response = await google_calendar_1.calendar.events.list({
                    calendarId: calendarData.google_calendar_id,
                    timeMin: suggestionStart.toJSDate().toISOString(),
                    timeMax: suggestionStart.plus({ minutes: service.duration }).toJSDate().toISOString(),
                    singleEvents: true,
                    orderBy: 'startTime'
                });
                const conflictingEvents = (response.data.items || []).filter(event => {
                    if (event.transparency === 'transparent' || event.status === 'cancelled') {
                        return false;
                    }
                    const eventStart = new Date(event.start?.dateTime || event.start?.date || '');
                    const eventEnd = new Date(event.end?.dateTime || event.end?.date || '');
                    const slotStart = suggestionStart.toJSDate();
                    const slotEnd = suggestionStart.plus({ minutes: service.duration }).toJSDate();
                    return (eventStart < slotEnd) && (eventEnd > slotStart);
                });
                if (conflictingEvents.length > 0) {
                    conflictingSuggestions.push({
                        suggestion,
                        conflicts: conflictingEvents
                    });
                }
            }
            catch (error) {
                console.error(`Erro verificando sugest√£o ${suggestion.start_datetime}:`, error);
            }
        }
        console.log(`üî¥ Sugest√µes com conflito: ${conflictingSuggestions.length}`);
        conflictingSuggestions.forEach((conflict, index) => {
            console.log(`\n${index + 1}. Conflito detectado:`);
            console.log(`   Sugest√£o: ${conflict.suggestion.start_datetime} (${conflict.suggestion.calendar_name})`);
            console.log(`   Conflitos:`);
            conflict.conflicts.forEach((event) => {
                console.log(`     - ${event.summary || 'Sem t√≠tulo'}`);
                console.log(`       ${event.start?.dateTime || event.start?.date} at√© ${event.end?.dateTime || event.end?.date}`);
            });
        });
        if (conflictingSuggestions.length === 0) {
            console.log('‚úÖ Nenhum conflito detectado na verifica√ß√£o manual');
        }
        else {
            console.log(`\nüí° PROBLEMA IDENTIFICADO: A API est√° sugerindo ${conflictingSuggestions.length} hor√°rios que t√™m conflitos!`);
            console.log('\nüîß POSS√çVEIS CAUSAS:');
            console.log('1. Bug na l√≥gica de sobreposi√ß√£o de eventos');
            console.log('2. Problema com timezone/convers√£o de datas');
            console.log('3. Cache de eventos antigo no Google Calendar');
            console.log('4. Filtros de transparency/cancelled n√£o funcionando');
        }
    }
    catch (error) {
        console.error('‚ùå Erro geral no debug:', error);
    }
}
// Fun√ß√£o adicional para testar um hor√°rio espec√≠fico step-by-step
async function debugSpecificSlot() {
    console.log('\nüîß DEBUG ESPEC√çFICO DO HOR√ÅRIO 14:00...\n');
    const TEST_TIME = "2025-08-26T14:00:00.000-03:00";
    const SERVICE_ID = "8e5fa7fc-7095-4b10-b99b-965fd1a81ecc";
    const CALENDAR_ID = "c0170c60-6640-4d70-936b-486a148cc375";
    try {
        // 1. Buscar dados do calend√°rio
        const { data: calendarData } = await supabase_1.supabase
            .from('calendars')
            .select('google_calendar_id, name')
            .eq('id', CALENDAR_ID)
            .single();
        if (!calendarData) {
            console.error('‚ùå Calend√°rio n√£o encontrado');
            return;
        }
        // 2. Buscar dados do servi√ßo
        const { data: service } = await supabase_1.supabase
            .from('services')
            .select('duration, buffer_before, buffer_after')
            .eq('id', SERVICE_ID)
            .single();
        if (!service) {
            console.error('‚ùå Servi√ßo n√£o encontrado');
            return;
        }
        // 3. Calcular hor√°rios com timezone correto
        const startTime = luxon_1.DateTime.fromISO(TEST_TIME, { setZone: true });
        const endTime = startTime.plus({ minutes: service.duration });
        const totalStart = startTime.minus({ minutes: service.buffer_before || 0 });
        const totalEnd = endTime.plus({ minutes: service.buffer_after || 0 });
        console.log('‚è∞ Hor√°rios calculados:');
        console.log(`   Solicitado: ${TEST_TIME}`);
        console.log(`   In√≠cio real: ${startTime.toString()}`);
        console.log(`   Fim real: ${endTime.toString()}`);
        console.log(`   Com buffer in√≠cio: ${totalStart.toString()}`);
        console.log(`   Com buffer fim: ${totalEnd.toString()}`);
        console.log(`   Timezone: ${startTime.zoneName}`);
        console.log(`   Offset: ${startTime.offset} minutos`);
        // 4. Buscar eventos no per√≠odo exato
        console.log('\nüîç Buscando eventos no Google Calendar...');
        const response = await google_calendar_1.calendar.events.list({
            calendarId: calendarData.google_calendar_id,
            timeMin: totalStart.toJSDate().toISOString(),
            timeMax: totalEnd.toJSDate().toISOString(),
            singleEvents: true,
            orderBy: 'startTime'
        });
        const events = response.data.items || [];
        console.log(`üìä Query Google Calendar:`);
        console.log(`   Calendar ID: ${calendarData.google_calendar_id}`);
        console.log(`   Time Min: ${totalStart.toJSDate().toISOString()}`);
        console.log(`   Time Max: ${totalEnd.toJSDate().toISOString()}`);
        console.log(`   Eventos retornados: ${events.length}`);
        if (events.length > 0) {
            console.log('\nüìã Eventos que podem causar conflito:');
            events.forEach((event, index) => {
                const eventStart = new Date(event.start?.dateTime || event.start?.date || '');
                const eventEnd = new Date(event.end?.dateTime || event.end?.date || '');
                // Verificar sobreposi√ß√£o exata
                const hasOverlap = (eventStart < totalEnd.toJSDate()) && (eventEnd > totalStart.toJSDate());
                const isTransparent = event.transparency === 'transparent';
                const isCancelled = event.status === 'cancelled';
                const wouldBlock = hasOverlap && !isTransparent && !isCancelled;
                console.log(`\n  ${index + 1}. ${event.summary || 'Sem t√≠tulo'}`);
                console.log(`     In√≠cio do evento: ${event.start?.dateTime || event.start?.date}`);
                console.log(`     Fim do evento: ${event.end?.dateTime || event.end?.date}`);
                console.log(`     Status: ${event.status}`);
                console.log(`     Transparency: ${event.transparency || 'opaque'}`);
                console.log(`     Tem sobreposi√ß√£o: ${hasOverlap ? 'üî¥ SIM' : 'üü¢ N√ÉO'}`);
                console.log(`     √â transparente: ${isTransparent ? 'üü¢ SIM' : 'üî¥ N√ÉO'}`);
                console.log(`     √â cancelado: ${isCancelled ? 'üü¢ SIM' : 'üî¥ N√ÉO'}`);
                console.log(`     üéØ BLOQUEIA: ${wouldBlock ? 'üî¥ SIM' : 'üü¢ N√ÉO'}`);
            });
        }
        else {
            console.log('‚úÖ Nenhum evento encontrado no per√≠odo - hor√°rio deveria estar dispon√≠vel');
        }
        // 5. Testar o m√©todo checkAvailability
        console.log('\nüìã 5. Testando m√©todo checkAvailability...');
        const availabilityService = new availability_1.AvailabilityService();
        const checkResult = await availabilityService.checkAvailability(TEST_TIME, SERVICE_ID, CALENDAR_ID);
        console.log('üìä Resultado checkAvailability:', checkResult);
    }
    catch (error) {
        console.error('‚ùå Erro no debug espec√≠fico:', error);
    }
}
async function main() {
    await debugAvailabilityIssue();
    await debugSpecificSlot();
}
// Para executar: npm run debug:availability
main().catch(console.error);
